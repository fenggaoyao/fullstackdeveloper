# 星期三

- 想说说这一年转变我想说说这一年来多来转变吧
  差不多两年，从相对封闭工厂环境出来到你那里，到你那学习，其实是打开一个新窗口，首先是我知道自己基本功不扎实，想实现这样一个注塑工业软件，是很吃力。为此我进行学习和探索
  总结起来，之前我眼里和思考的只有业务数据，如何将数据展示起来，进行简单加工运算，再用 web 组件进行展示就可以了，这是最速成的方法，最关键于是如何将这些有机构建起来，解决难的问题》编程能力，解决逻辑问题》架构，人的问题》工程,涉及很多知识点，对我来说还是黑盒子，想要构建一个可持续的注塑工业软件来说，是很遥远的距离。

- 在子组件遇到 slot 标签，说明此处理需要此父节点存储内容，此处使用一个 withctx 的高阶函数，在创建父组件的，当前实例使用闭包的形式存储起来，此要渲染，即执行，同时将本节点的参数作为参数传入

- \$slot 是一个[string:vnode]的组合，它是*子组件*里的，instance.\$slot.default
- withCtx 返回一个高阶函数，接收的是\_renderSlot()，是实现组件参数回传
  slot ? slot(props) : fallback ? fallback() : []

blockstact 表示 block 树，currentblock 表示当前 block
openblock,往当前 blockStack 里 push 一个新 block,这个要先执行，执行 createBlock 时已经创建了 children 节点
父节点的 createBlock 函数执行前。子节点就已经通过 createVnode 创建了对应的 vnode

组件带 v-slot 指令，

<slot name="" :带变量，是 vnode 变量> rendSlot 返回：vonde,

```javascript
export function renderSlot(
  slots: Slots,
  name: string,
  props: Data = {},
  // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback?: () => VNodeArrayChildren
): VNode {
  let slot = slots[name]

  if (__DEV__ && slot && slot.length > 1) {
    warn(
      `SSR-optimized slot function detected in a non-SSR-optimized render ` +
        `function. You need to mark this component with $dynamic-slots in the ` +
        `parent template.`
    )
    slot = () => []
  }

  // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.
  isRenderingCompiledSlot++
  const rendered = (openBlock(),
  createBlock(
    Fragment,
    { key: props.key },
    slot ? slot(props) : fallback ? fallback() : [],
    (slots as RawSlots)._ === SlotFlags.STABLE
      ? PatchFlags.STABLE_FRAGMENT
      : PatchFlags.BAIL
  ))
  isRenderingCompiledSlot--
  return rendered
}


export function withCtx(
  fn: Slot,
  ctx: ComponentInternalInstance | null = currentRenderingInstance
) {
  if (!ctx) return fn
  const renderFnWithContext = (...args: any[]) => {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we need to push a null block to
    // avoid that. This isn't necessary if rendering a compiled `<slot>`.
    if (!isRenderingCompiledSlot) {
      openBlock(true /* null block that disables tracking */)
    }
    const owner = currentRenderingInstance
    setCurrentRenderingInstance(ctx)
    const res = fn(...args)
    setCurrentRenderingInstance(owner)
    if (!isRenderingCompiledSlot) {
      closeBlock()
    }
    return res
  }
  renderFnWithContext._c = true
  return renderFnWithContext
}

export const blockStack: (VNode[] | null)[] = []
let currentBlock: VNode[] | null = null
export function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []))
}
export function closeBlock() {
  blockStack.pop()
  currentBlock = blockStack[blockStack.length - 1] || null
}
export function createBlock(
  type: VNodeTypes | ClassComponent,
  props?: Record<string, any> | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  const vnode = createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true /* isBlock: prevent a block from tracking itself */
  )
  // save current block children on the block vnode
  vnode.dynamicChildren = currentBlock || EMPTY_ARR
  // close block
  closeBlock()
  // a block is always going to be patched, so track it as a child of its
  // parent block
  if (shouldTrack > 0 && currentBlock) {
    currentBlock.push(vnode)
  }
  return vnode
}


```

父组件定义使用组件的插槽时，slot 部分变成对象{}，这个在 instance 里，我们就完成了子组件插槽内容的渲染。可以看到，插槽的实现实际上就是一种延时渲染，把父组件中编写的插槽内容保存到一个对象上，并且把具体渲染 DOM 的代码用函数的方式封装，然后在子组件渲染的时候，根据插槽名在对象中找到对应的函数，然后执行这些函数做真正的渲染。
要切换 instance 使用是父组件 instance

增加了 transition 的学习，动画分 animation 关键帧动画和 transition 补间动画两种

状态主要分进入，退出，从 from active 到 to 三种，绑定 name 是改变名字，此外还有@before-enter @enter
@before-leave @leave
js 函数分钩子，如 beforeenter,enter afterenter
