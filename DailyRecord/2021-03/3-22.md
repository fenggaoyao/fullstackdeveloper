# 星期一

## in out
out:代表协变，只能当返回值类型使用 <父类>  = new  <子类>（）,不能作为方法实参
in:代表逆变，只能用作方法实参,不能用作返回值类型。只用在委托和接口中；

但是它的用处是不让方法内部对其进行赋值新的对象，如下代码：






```C#
public interface ITypeList<in TBaseType> : IList<Type>

IgnoredTypes.Any(t => t.IsAssignableFrom(type))

 typeof(AbpAsyncDeterminationInterceptor<>).MakeGenericType(interceptor)
 type.GetCustomAttribute<DependencyAttribute>(true)
 type.IsDefined(typeof(DisableConventionalRegistrationAttribute), true)
 entity is IMultiTenant multiTenantEntity
  eventData.GetType().GetProperty("Entity")

     typeof(AbpAspNetCoreSignalRModule)
                .GetMethod("MapHub", BindingFlags.Static | BindingFlags.NonPublic);

  context.ImplementationType.IsDefined(typeof(DisableAutoHubMapAttribute), true);

     MapHubGenericMethodInfo
                .MakeGenericMethod(hubType)
                .Invoke(
                    this,
                    new object[]
                    {
                        endpoints,
                        pattern,
                        configureOptions
                    }
                );

```

从一个对象的方法执行的角度来看，有什么
```C#
IAbpMethodInvocation
{
  object TargetObject { get; } //对象
  MethodInfo Method { get; } //对象方法
  object[] Arguments { get; } //对象参数
  Type[] GenericArguments { get; }   //Invocation.GenericArguments
  object ReturnValue { get; set; } //对象返回值 

  Task ProceedAsync();//调用

}

AuditingInterceptor
DynamicHttpProxyInterceptor<TService>
AuthorizationInterceptor
FeatureInterceptor
UnitOfWorkInterceptor

context.Services.AddTransient(typeof(AbpAsyncDeterminationInterceptor<>));
```

注意类中只有标记virtual才能实现拦截